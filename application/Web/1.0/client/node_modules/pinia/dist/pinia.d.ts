import { App } from 'vue-demi';
import { ComputedRef } from 'vue-demi';
import { DebuggerEvent } from 'vue-demi';
import { EffectScope } from 'vue-demi';
import { Plugin as Plugin_2 } from 'vue-demi';
import { Ref } from 'vue-demi';
import { ToRefs } from 'vue-demi';
import { UnwrapRef } from 'vue-demi';
import { WatchOptions } from 'vue-demi';

/**
 * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.
 *
 * @example
 * ```js
 * const useUser = defineStore(...)
 * if (import.meta.hot) {
 *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))
 * }
 * ```
 *
 * @param initialUseStore - return of the defineStore to hot update
 * @param hot - `import.meta.hot`
 */
export declare function acceptHMRUpdate(initialUseStore: StoreDefinition, hot: any): (newModule: any) => any;

/**
 * Type of an object of Actions.
 *
 * @internal
 */
export declare type ActionsTree = Record<string, _Method>;

/**
 * Creates a Pinia instance to be used by the application
 */
export declare function createPinia(): Pinia;

/**
 * Recursive `Partial<T>`. Used by {@link Store.$patch}.
 *
 * @internal
 */
declare type DeepPartial<T> = {
    [K in keyof T]?: DeepPartial<T[K]>;
};

/**
 * Options parameter of `defineStore()` for setup stores. Can be extended to
 * augment stores with the plugin API. @see {@link DefineStoreOptionsBase}.
 */
export declare interface DefineSetupStoreOptions<Id extends string, S extends StateTree, G, A> extends DefineStoreOptionsBase<S, Store<Id, S, G, A>> {
    /**
     * Extracted actions. Added by useStore(). SHOULD NOT be added by the user when
     * creating the store. Can be used in plugins to get the list of actions in a
     * store defined with a setup function. Note this is always defined
     */
    actions?: A;
}

/**
 * Creates a `useStore` function that retrieves the store instance
 *
 * @param id - id of the store (must be unique)
 * @param options - options to define the store
 */
export declare function defineStore<Id extends string, S extends StateTree = {}, G extends GettersTree<S> = {}, A = {}>(id: Id, options: Omit<DefineStoreOptions<Id, S, G, A>, 'id'>): StoreDefinition<Id, S, G, A>;

/**
 * Creates a `useStore` function that retrieves the store instance
 *
 * @param options - options to define the store
 */
export declare function defineStore<Id extends string, S extends StateTree = {}, G extends GettersTree<S> = {}, A = {}>(options: DefineStoreOptions<Id, S, G, A>): StoreDefinition<Id, S, G, A>;

/**
 * Creates a `useStore` function that retrieves the store instance
 *
 * @param id - id of the store (must be unique)
 * @param storeSetup - function that defines the store
 * @param options - extra options
 */
export declare function defineStore<Id extends string, SS>(id: Id, storeSetup: () => SS, options?: DefineSetupStoreOptions<Id, _ExtractStateFromSetupStore<SS>, _ExtractGettersFromSetupStore<SS>, _ExtractActionsFromSetupStore<SS>>): StoreDefinition<Id, _ExtractStateFromSetupStore<SS>, _ExtractGettersFromSetupStore<SS>, _ExtractActionsFromSetupStore<SS>>;

/**
 * Options parameter of `defineStore()` for option stores. Can be extended to
 * augment stores with the plugin API. @see {@link DefineStoreOptionsBase}.
 */
export declare interface DefineStoreOptions<Id extends string, S extends StateTree, G, A> extends DefineStoreOptionsBase<S, Store<Id, S, G, A>> {
    /**
     * Unique string key to identify the store across the application.
     */
    id: Id;
    /**
     * Function to create a fresh state. **Must be an arrow function** to ensure
     * correct typings!
     */
    state?: () => S;
    /**
     * Optional object of getters.
     */
    getters?: G & ThisType<UnwrapRef<S> & StoreWithGetters<G> & PiniaCustomProperties> & GettersTree<S>;
    /**
     * Optional object of actions.
     */
    actions?: A & ThisType<A & UnwrapRef<S> & StoreWithState<Id, S, G, A> & StoreWithGetters<G> & PiniaCustomProperties>;
}

/**
 * Options passed to `defineStore()` that are common between option and setup
 * stores. Extend this interface if you want to add custom options to both kinds
 * of stores.
 */
export declare interface DefineStoreOptionsBase<S extends StateTree, Store> {
    /**
     * Allows hydrating the store during SSR when there is an available state in
     * pinia.state.
     *
     * @param store - the store
     * @param initialState - initialState
     */
    hydrate?(store: Store, initialState: UnwrapRef<S>): void;
}

/**
 * Available `options` when creating a pinia plugin.
 */
export declare interface DefineStoreOptionsInPlugin<Id extends string, S extends StateTree, G, A> extends Omit<DefineStoreOptions<Id, S, G, A>, 'id' | 'actions'> {
    /**
     * Extracted object of actions. Added by useStore() when the store is built
     * using the setup API, otherwise uses the one passed to `defineStore()`.
     * Defaults to an empty object if no actions are defined.
     */
    actions: A;
    /**
     * Id of the store. Only available when the options API is used.
     *
     * @deprecated  Use `store.$id` instead.
     */
    id?: Id;
}

/**
 * @internal
 */
declare type _ExtractActionsFromSetupStore<SS> = SS extends undefined | void ? {} : {
    [K in keyof SS as SS[K] extends _Method ? K : never]: SS[K];
};

/**
 * @internal
 */
declare type _ExtractGettersFromSetupStore<SS> = SS extends undefined | void ? {} : {
    [K in keyof SS as SS[K] extends ComputedRef ? K : never]: UnwrapRef<SS[K]>;
};

/**
 * @internal
 */
declare type _ExtractStateFromSetupStore<SS> = SS extends undefined | void ? {} : {
    [K in keyof SS as SS[K] extends _Method | ComputedRef ? never : K]: UnwrapRef<SS[K]>;
};

/**
 * Generic and type-unsafe version of Store. Doesn't fail on access with
 * strings, making it much easier to write generic functions that do not care
 * about the kind of store that is passed.
 * @deprecated Use `StoreGeneric` instead
 */
export declare type GenericStore<Id extends string = string, S extends StateTree = StateTree, G = GettersTree<S>, A = ActionsTree> = StoreWithState<Id, S, G, A> & UnwrapRef<S> & StoreWithGetters<G> & A & PiniaCustomProperties<Id, S, G, A> & PiniaCustomStateProperties<S>;

/**
 * Get the currently active pinia if there is any.
 */
export declare const getActivePinia: () => Pinia | undefined;

/**
 * Type of an object of Getters that infers the argument.
 *
 * @internal
 */
export declare type GettersTree<S extends StateTree> = Record<string, ((state: UnwrapRef<S> & UnwrapRef<PiniaCustomStateProperties<S>>) => any) | (() => any)>;

/**
 * Allows directly using actions from your store without using the composition
 * API (`setup()`) by generating an object to be spread in the `methods` field
 * of a component. The values of the object are the actions while the keys are
 * the names of the resulting methods.
 *
 * @example
 * ```js
 * export default {
 *   methods: {
 *     // other methods properties
 *     // useCounterStore has two actions named `increment` and `setCount`
 *     ...mapActions(useCounterStore, { moar: 'increment', setIt: 'setCount' })
 *   },
 *
 *   created() {
 *     this.moar()
 *     this.setIt(2)
 *   }
 * }
 * ```
 *
 * @param useStore - store to map from
 * @param keyMapper - object to define new names for the actions
 */
export declare function mapActions<Id extends string, S extends StateTree, G extends GettersTree<S>, A, KeyMapper extends Record<string, keyof A>>(useStore: StoreDefinition<Id, S, G, A>, keyMapper: KeyMapper): _MapActionsObjectReturn<A, KeyMapper>;

/**
 * Allows directly using actions from your store without using the composition
 * API (`setup()`) by generating an object to be spread in the `methods` field
 * of a component.
 *
 * @example
 * ```js
 * export default {
 *   methods: {
 *     // other methods properties
 *     ...mapActions(useCounterStore, ['increment', 'setCount'])
 *   },
 *
 *   created() {
 *     this.increment()
 *     this.setCount(2) // pass arguments as usual
 *   }
 * }
 * ```
 *
 * @param useStore - store to map from
 * @param keys - array of action names to map
 */
export declare function mapActions<Id extends string, S extends StateTree, G extends GettersTree<S>, A>(useStore: StoreDefinition<Id, S, G, A>, keys: Array<keyof A>): _MapActionsReturn<A>;

/**
 * @internal
 */
export declare type _MapActionsObjectReturn<A, T extends Record<string, keyof A>> = {
    [key in keyof T]: A[T[key]];
};

/**
 * @internal
 */
export declare type _MapActionsReturn<A> = {
    [key in keyof A]: A[key];
};

/**
 * Alias for `mapState()`. You should use `mapState()` instead.
 * @deprecated use `mapState()` instead.
 */
export declare const mapGetters: typeof mapState;

/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component. The values of the object are the state properties/getters
 * while the keys are the names of the resulting computed properties.
 * Optionally, you can also pass a custom function that will receive the store
 * as its first argument. Note that while it has access to the component
 * instance via `this`, it won't be typed.
 *
 * @example
 * ```js
 * export default {
 *   computed: {
 *     // other computed properties
 *     // useCounterStore has a state property named `count` and a getter `double`
 *     ...mapState(useCounterStore, {
 *       n: 'count',
 *       triple: store => store.n * 3,
 *       // note we can't use an arrow function if we want to use `this`
 *       custom(store) {
 *         return this.someComponentValue + store.n
 *       },
 *       doubleN: 'double'
 *     })
 *   },
 *
 *   created() {
 *     this.n // 2
 *     this.doubleN // 4
 *   }
 * }
 * ```
 *
 * @param useStore - store to map from
 * @param keyMapper - object of state properties or getters
 */
export declare function mapState<Id extends string, S extends StateTree, G extends GettersTree<S>, A, KeyMapper extends Record<string, keyof S | keyof G | ((store: Store<Id, S, G, A>) => any)>>(useStore: StoreDefinition<Id, S, G, A>, keyMapper: KeyMapper): _MapStateObjectReturn<Id, S, G, A, KeyMapper>;

/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @example
 * ```js
 * export default {
 *   computed: {
 *     // other computed properties
 *     ...mapState(useCounterStore, ['count', 'double'])
 *   },
 *
 *   created() {
 *     this.count // 2
 *     this.double // 4
 *   }
 * }
 * ```
 *
 * @param useStore - store to map from
 * @param keys - array of state properties or getters
 */
export declare function mapState<Id extends string, S extends StateTree, G extends GettersTree<S>, A, Keys extends keyof S | keyof G>(useStore: StoreDefinition<Id, S, G, A>, keys: readonly Keys[]): _MapStateReturn<S, G, Keys>;

/**
 * @internal
 */
export declare type _MapStateObjectReturn<Id extends string, S extends StateTree, G extends GettersTree<S>, A, T extends Record<string, keyof S | keyof G | ((store: Store<Id, S, G, A>) => any)> = {}> = {
    [key in keyof T]: () => T[key] extends (store: any) => infer R ? R : T[key] extends keyof Store<Id, S, G, A> ? Store<Id, S, G, A>[T[key]] : never;
};

/**
 * @internal
 */
export declare type _MapStateReturn<S extends StateTree, G extends GettersTree<S>, Keys extends keyof S | keyof G = keyof S | keyof G> = {
    [key in Keys]: () => Store<string, S, G, {}>[key];
};

/**
 * Allows using stores without the composition API (`setup()`) by generating an
 * object to be spread in the `computed` field of a component. It accepts a list
 * of store definitions.
 *
 * @example
 * ```js
 * export default {
 *   computed: {
 *     // other computed properties
 *     ...mapStores(useUserStore, useCartStore)
 *   },
 *
 *   created() {
 *     this.userStore // store with id "user"
 *     this.cartStore // store with id "cart"
 *   }
 * }
 * ```
 *
 * @param stores - list of stores to map to an object
 */
export declare function mapStores<Stores extends any[]>(...stores: [...Stores]): _Spread<Stores>;

/**
 * Interface to allow customizing map helpers. Extend this interface with the
 * following properties:
 *
 * - `suffix`: string. Affects the suffix of `mapStores()`, defaults to `Store`.
 */
export declare interface MapStoresCustomization {
}

/**
 * Same as `mapState()` but creates computed setters as well so the state can be
 * modified. Differently from `mapState()`, only `state` properties can be
 * added.
 *
 * @param useStore - store to map from
 * @param keyMapper - object of state properties
 */
export declare function mapWritableState<Id extends string, S extends StateTree, G extends GettersTree<S>, A, KeyMapper extends Record<string, keyof S>>(useStore: StoreDefinition<Id, S, G, A>, keyMapper: KeyMapper): _MapWritableStateObjectReturn<S, KeyMapper>;

/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keys - array of state properties
 */
export declare function mapWritableState<Id extends string, S extends StateTree, G extends GettersTree<S>, A>(useStore: StoreDefinition<Id, S, G, A>, keys: Array<keyof S>): _MapWritableStateReturn<S>;

/**
 * @internal
 */
export declare type _MapWritableStateObjectReturn<S extends StateTree, T extends Record<string, keyof S>> = {
    [key in keyof T]: {
        get: () => S[T[key]];
        set: (value: S[T[key]]) => any;
    };
};

/**
 * @internal
 */
export declare type _MapWritableStateReturn<S extends StateTree> = {
    [key in keyof S]: {
        get: () => S[key];
        set: (value: S[key]) => any;
    };
};

/**
 * Generic type for a function that can infer arguments and return type
 *
 * @internal
 */
export declare type _Method = (...args: any[]) => any;

/**
 * Possible types for SubscriptionCallback
 */
export declare enum MutationType {
    /**
     * Direct mutation of the state:
     *
     * - `store.name = 'new name'`
     * - `store.$state.name = 'new name'`
     * - `store.list.push('new item')`
     */
    direct = "direct",
    /**
     * Mutated the state with `$patch` and an object
     *
     * - `store.$patch({ name: 'newName' })`
     */
    patchObject = "patch object",
    /**
     * Mutated the state with `$patch` and a function
     *
     * - `store.$patch(state => state.name = 'newName')`
     */
    patchFunction = "patch function"
}

/**
 * Every application must own its own pinia to be able to create stores
 */
export declare interface Pinia {
    install: Exclude<Plugin_2['install'], undefined>;
    /**
     * root state
     */
    state: Ref<Record<string, StateTree>>;
    /**
     * Adds a store plugin to extend every store
     *
     * @param plugin - store plugin to add
     */
    use(plugin: PiniaStorePlugin): Pinia;
    /**
     * Installed store plugins
     *
     * @internal
     */
    _p: Array<PiniaStorePlugin>;
    /**
     * App linked to this Pinia instance
     *
     * @internal
     */
    _a: App;
    /**
     * Effect scope the pinia is attached to
     *
     * @internal
     */
    _e: EffectScope;
    /**
     * Registry of stores used by this pinia.
     *
     * @internal
     */
    _s: Map<string, StoreGeneric>;
    /**
     * Added by `createTestingPinia()` to bypass `useStore(pinia)`.
     *
     * @internal
     */
    _testing?: boolean;
}

/**
 * Properties that are added to every store by `pinia.use()`.
 */
export declare interface PiniaCustomProperties<Id extends string = string, S extends StateTree = StateTree, G = GettersTree<S>, A = ActionsTree> {
}

/**
 * Properties that are added to every `store.$state` by `pinia.use()`.
 */
export declare interface PiniaCustomStateProperties<S extends StateTree = StateTree> {
}

/**
 * @deprecated use `PiniaVuePlugin` instead.
 */
export declare const PiniaPlugin: ((app: App<any>, ...options: any[]) => any) & {
    install?: ((app: App<any>, ...options: any[]) => any) | undefined;
};

/**
 * Context argument passed to Pinia plugins.
 */
export declare interface PiniaPluginContext<Id extends string = string, S extends StateTree = StateTree, G = GettersTree<S>, A = ActionsTree> {
    /**
     * pinia instance.
     */
    pinia: Pinia;
    /**
     * Current app created with `Vue.createApp()`.
     */
    app: App;
    /**
     * Current store being extended.
     */
    store: Store<Id, S, G, A>;
    /**
     * Current store being extended.
     */
    options: DefineStoreOptionsInPlugin<Id, S, G, A>;
}

/**
 * Plugin to extend every store
 */
export declare interface PiniaStorePlugin {
    /**
     * Plugin to extend every store. Returns an object to extend the store or
     * nothing.
     *
     * @param context - Context
     */
    (context: PiniaPluginContext): Partial<PiniaCustomProperties & PiniaCustomStateProperties> | void;
}

/**
 * Vue 2 Plugin that must be installed for pinia to work. Note **you don't need
 * this plugin if you are using Nuxt.js**. Use the `buildModule` instead:
 * https://pinia.esm.dev/ssr/nuxt.html.
 *
 * @example
 * ```js
 * import Vue from 'vue'
 * import { PiniaVuePlugin, createPinia } from 'pinia'
 *
 * Vue.use(PiniaVuePlugin)
 * const pinia = createPinia()
 *
 * new Vue({
 *   el: '#app',
 *   // ...
 *   pinia,
 * })
 * ```
 *
 * @param _Vue
 */
export declare const PiniaVuePlugin: Plugin_2;

/**
 * Sets or unsets the active pinia. Used in SSR and internally when calling
 * actions and getters
 *
 * @param pinia - Pinia instance
 */
export declare const setActivePinia: (pinia: Pinia | undefined) => Pinia | undefined;

/**
 * Changes the suffix added by `mapStores()`. Can be set to an empty string.
 * Defaults to `"Store"`. Make sure to extend the MapStoresCustomization
 * interface if you need are using TypeScript.
 *
 * @param suffix - new suffix
 */
export declare function setMapStoreSuffix(suffix: MapStoresCustomization extends Record<'suffix', string> ? MapStoresCustomization['suffix'] : string): void;

/**
 * @internal
 */
export declare type _Spread<A extends readonly any[]> = A extends [infer L, ...infer R] ? _StoreObject<L> & _Spread<R> : unknown;

/**
 * Generic state of a Store
 */
export declare type StateTree = Record<string | number | symbol, any>;

/**
 * Store type to build a store
 */
export declare type Store<Id extends string = string, S extends StateTree = {}, G = {}, A = {}> = StoreWithState<Id, S, G, A> & UnwrapRef<S> & StoreWithGetters<G> & (ActionsTree extends A ? {} : A) & PiniaCustomProperties<Id, S, G, A> & PiniaCustomStateProperties<S>;

/**
 * Extract the actions of a store type. Works with both a Setup Store or an
 * Options Store.
 */
export declare type StoreActions<SS> = SS extends Store<string, StateTree, GettersTree<StateTree>, infer A> ? A : _ExtractActionsFromSetupStore<SS>;

/**
 * Return type of `defineStore()`. Function that allows instantiating a store.
 */
export declare interface StoreDefinition<Id extends string = string, S extends StateTree = StateTree, G = GettersTree<S>, A = ActionsTree> {
    /**
     * Returns a store, creates it if necessary.
     *
     * @param pinia - Pinia instance to retrieve the store
     * @param hot - dev only hot module replacement
     */
    (pinia?: Pinia | null | undefined, hot?: StoreGeneric): Store<Id, S, G, A>;
    /**
     * Id of the store. Used by map helpers.
     */
    $id: Id;
    /**
     * Dev only pinia for HMR.
     *
     * @internal
     */
    _pinia?: Pinia;
}

/**
 * Generic and type-unsafe version of Store. Doesn't fail on access with
 * strings, making it much easier to write generic functions that do not care
 * about the kind of store that is passed.
 */
export declare type StoreGeneric = Store<string, StateTree, GettersTree<StateTree>, ActionsTree>;

/**
 * Extract the getters of a store type. Works with both a Setup Store or an
 * Options Store.
 */
export declare type StoreGetters<SS> = SS extends Store<string, StateTree, infer G, ActionsTree> ? StoreWithGetters<G> : _ExtractGettersFromSetupStore<SS>;

/**
 * @internal
 */
export declare type _StoreObject<S> = S extends StoreDefinition<infer Ids, infer State, infer Getters, infer Actions> ? {
    [Id in `${Ids}${MapStoresCustomization extends Record<'suffix', string> ? MapStoresCustomization['suffix'] : 'Store'}`]: () => Store<Id extends `${infer RealId}${MapStoresCustomization extends Record<'suffix', string> ? MapStoresCustomization['suffix'] : 'Store'}` ? RealId : string, State, Getters, Actions>;
} : {};

/**
 * Argument of `store.$onAction()`
 */
export declare type StoreOnActionListener<Id extends string, S extends StateTree, G, A> = (context: StoreOnActionListenerContext<Id, S, G, {} extends A ? ActionsTree : A>) => void;

/**
 * Context object passed to callbacks of `store.$onAction(context => {})`
 * TODO: should have only the Id, the Store and Actions to generate the proper object
 */
export declare type StoreOnActionListenerContext<Id extends string, S extends StateTree, G, A> = ActionsTree extends A ? _StoreOnActionListenerContext<StoreGeneric, string, ActionsTree> : {
    [Name in keyof A]: Name extends string ? _StoreOnActionListenerContext<Store<Id, S, G, A>, Name, A> : never;
}[keyof A];

declare type _StoreOnActionListenerContext<Store, ActionName extends string, A> = {
    /**
     * Name of the action
     */
    name: ActionName;
    /**
     * Store that is invoking the action
     */
    store: Store;
    /**
     * Parameters passed to the action
     */
    args: A extends Record<ActionName, _Method> ? Parameters<A[ActionName]> : unknown[];
    /**
     * Sets up a hook once the action is finished. It receives the return value
     * of the action, if it's a Promise, it will be unwrapped. Can return a
     * value (other than `undefined`) to **override** the returned value.
     */
    after: (callback: A extends Record<ActionName, _Method> ? (resolvedReturn: UnwrapPromise<ReturnType<A[ActionName]>>) => void | ReturnType<A[ActionName]> | UnwrapPromise<ReturnType<A[ActionName]>> : () => void) => void;
    /**
     * Sets up a hook if the action fails. Return `false` to catch the error and
     * stop it fro propagating.
     */
    onError: (callback: (error: unknown) => unknown | false) => void;
};

/**
 * Properties of a store.
 */
export declare interface StoreProperties<Id extends string> {
    /**
     * Unique identifier of the store
     */
    $id: Id;
    /**
     * Private property defining the pinia the store is attached to.
     *
     * @internal
     */
    _p: Pinia;
    /**
     * Used by devtools plugin to retrieve getters. Removed in production.
     *
     * @internal
     */
    _getters?: string[];
    /**
     * Used by devtools plugin to retrieve properties added with plugins. Removed
     * in production. Can be used by the user to add property keys of the store
     * that should be displayed in devtools.
     *
     * @internal
     */
    _customProperties: Set<string>;
    /**
     * Handles a HMR replacement of this store. Dev Only.
     *
     * @internal
     */
    _hotUpdate(useStore: StoreGeneric): void;
    /**
     * Allows pausing some of the watching mechanisms while the store is being
     * patched with a newer version.
     *
     * @internal
     */
    _hotUpdating: boolean;
    /**
     * Payload of the hmr update. Dev only.
     *
     * @internal
     */
    _hmrPayload: {
        state: string[];
        hotState: Ref<StateTree>;
        actions: ActionsTree;
        getters: ActionsTree;
    };
}

/**
 * Extract the state of a store type. Works with both a Setup Store or an
 * Options Store. Note this unwraps refs.
 */
export declare type StoreState<SS> = SS extends Store<string, infer S, GettersTree<StateTree>, ActionsTree> ? UnwrapRef<S> : _ExtractStateFromSetupStore<SS>;

/**
 * Creates an object of references with all the state, getters, and plugin-added
 * state properties of the store. Similar to `toRefs()` but specifically
 * designed for Pinia stores so methods and non reactive properties are
 * completely ignored.
 *
 * @param store - store to extract the refs from
 */
export declare function storeToRefs<SS extends StoreGeneric>(store: SS): ToRefs<StoreState<SS> & StoreGetters<SS> & PiniaCustomStateProperties<StoreState<SS>>>;

/**
 * Store augmented for actions
 *
 * @internal
 */
export declare type StoreWithActions<A> = {
    [k in keyof A]: A[k] extends (...args: infer P) => infer R ? (...args: P) => R : never;
};

/**
 * Store augmented with getters
 *
 * @internal
 */
export declare type StoreWithGetters<G> = {
    readonly [k in keyof G]: G[k] extends (...args: any[]) => infer R ? R : UnwrapRef<G[k]>;
};

/**
 * Base store with state and functions
 * @internal
 */
export declare interface StoreWithState<Id extends string, S extends StateTree, G, A> extends StoreProperties<Id> {
    /**
     * State of the Store. Setting it will replace the whole state.
     */
    $state: UnwrapRef<S> & PiniaCustomStateProperties<S>;
    /**
     * Applies a state patch to current state. Allows passing nested values
     *
     * @param partialState - patch to apply to the state
     */
    $patch(partialState: DeepPartial<UnwrapRef<S>>): void;
    /**
     * Group multiple changes into one function. Useful when mutating objects like
     * Sets or arrays and applying an object patch isn't practical, e.g. appending
     * to an array.
     *
     * @param stateMutator - function that mutates `state`, cannot be async
     */
    $patch<F extends (state: UnwrapRef<S>) => void>(stateMutator: ReturnType<F> extends Promise<any> ? never : F): void;
    /**
     * Resets the store to its initial state by building a new state object.
     * TODO: make this options only
     */
    $reset(): void;
    /**
     * Setups a callback to be called whenever the state changes. It also returns
     * a function to remove the callback. Note than when calling
     * `store.$subscribe()` inside of a component, it will be automatically
     * cleanup up when the component gets unmounted unless `detached` is set to
     * true.
     *
     * @param callback - callback passed to the watcher
     * @param options - `watch` options + `detached` to detach the subscription
     * from the context (usually a component) this is called from
     * @returns function that removes the watcher
     */
    $subscribe(callback: SubscriptionCallback<S>, options?: {
        detached?: boolean;
    } & WatchOptions): () => void;
    /**
     * Setups a callback to be called whenever the state changes. It also returns
     * a function to remove the callback. Note than when calling
     * `store.$subscribe()` inside of a component, it will be automatically
     * cleanup up when the component gets unmounted unless `detached` is set to
     * true.
     *
     * @deprecated use `store.$subscribe(fn, { detached: true })` instead.
     *
     * @param callback - callback passed to the watcher
     * @param detached - detach the subscription from the context this is called
     * from
     * @returns function that removes the watcher
     */
    $subscribe(callback: SubscriptionCallback<S>, detached?: boolean): () => void;
    /**
     * @alpha Please send feedback at https://github.com/posva/pinia/issues/240
     * Setups a callback to be called every time an action is about to get
     * invoked. The callback receives an object with all the relevant information
     * of the invoked action:
     * - `store`: the store it is invoked on
     * - `name`: The name of the action
     * - `args`: The parameters passed to the action
     *
     * On top of these, it receives two functions that allow setting up a callback
     * once the action finishes or when it fails.
     *
     * It also returns a function to remove the callback. Note than when calling
     * `store.$onAction()` inside of a component, it will be automatically cleanup
     * up when the component gets unmounted unless `detached` is set to true.
     *
     * @example
     *
     *```js
     *store.$onAction(({ after, onError }) => {
     *  // Here you could share variables between all of the hooks as well as
     *  // setting up watchers and clean them up
     *  after((resolvedValue) => {
     *    // can be used to cleanup side effects
     * .  // `resolvedValue` is the value returned by the action, if it's a
     * .  // Promise, it will be the resolved value instead of the Promise
     *  })
     *  onError((error) => {
     *    // can be used to pass up errors
     *  })
     *})
     *```
     *
     * @param callback - callback called before every action
     * @param detached - detach the subscription from the context this is called from
     * @returns function that removes the watcher
     */
    $onAction(callback: StoreOnActionListener<Id, S, G, A>, detached?: boolean): () => void;
    /**
     * Stops the associated effect scope of the store and remove it from the store
     * registry. Plugins can override this method to cleanup any added effects.
     * e.g. devtools plugin stops displaying disposed stores from devtools.
     */
    $dispose(): void;
    /**
     * Vue 2 only. Is the store ready. Used for store cross usage. Getters automatically compute when they are added to
     * the store, before the store is actually ready, this allows to avoid calling the computed function yet.
     *
     * @internal
     */
    _r?: boolean;
}

/**
 * Callback of a subscription
 */
export declare type SubscriptionCallback<S> = (
/**
 * Object with information relative to the store mutation that triggered the
 * subscription.
 */
mutation: SubscriptionCallbackMutation<S>, 
/**
 * State of the store when the subscription is triggered. Same as
 * `store.$state`.
 */
state: UnwrapRef<S>) => void;

/**
 * Context object passed to a subscription callback.
 */
export declare type SubscriptionCallbackMutation<S> = SubscriptionCallbackMutationDirect | SubscriptionCallbackMutationPatchObject<S> | SubscriptionCallbackMutationPatchFunction;

/**
 * Base type for the context passed to a subscription callback.
 *
 * @internal
 */
export declare interface _SubscriptionCallbackMutationBase {
    /**
     * Type of the mutation.
     */
    type: MutationType;
    /**
     * `id` of the store doing the mutation.
     */
    storeId: string;
}

/**
 * Context passed to a subscription callback when directly mutating the state of
 * a store with `store.someState = newValue` or `store.$state.someState =
 * newValue`.
 */
export declare interface SubscriptionCallbackMutationDirect extends _SubscriptionCallbackMutationBase {
    type: MutationType.direct;
    /**
     * DEV ONLY. Different mutation calls.
     */
    events: DebuggerEvent;
}

/**
 * Context passed to a subscription callback when `store.$patch()` is called
 * with a function.
 */
export declare interface SubscriptionCallbackMutationPatchFunction extends _SubscriptionCallbackMutationBase {
    type: MutationType.patchFunction;
    /**
     * DEV ONLY. Array of all the mutations done inside of the callback.
     */
    events: DebuggerEvent[];
}

/**
 * Context passed to a subscription callback when `store.$patch()` is called
 * with an object.
 */
export declare interface SubscriptionCallbackMutationPatchObject<S> extends _SubscriptionCallbackMutationBase {
    type: MutationType.patchObject;
    /**
     * DEV ONLY. Array for patch calls.
     */
    events: DebuggerEvent[];
    /**
     * Object passed to `store.$patch()`.
     */
    payload: DeepPartial<S>;
}

declare type UnwrapPromise<T> = T extends Promise<infer V> ? V : T;

export { }
